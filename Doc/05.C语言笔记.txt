C语言的灵魂
 1.指针 ---首先必须非常明确：指针的实质就是个变量，它跟普通变量没有任何本质区别。
           指针完整的名字应该叫指针变量，简称为指针。 
 int main（void）
 {
    //a的实质就是一个便一起的符号，在编译器中a和一个内存空间联系起来
	   这个内存就是a所代表的哪一个变量
    int a； //定义了一个int类型的变量，叫做a
	int *p；//定义了一个指针变量，叫做p，p指向一个int类型的变量
	
	a=4；  //可以编译
	p=4；  //编译器不允许，因为指针变量虽然实质是普通的变量，但是它的用途和普通
	         变量不同。指针变量存储的是另外一个变量的地址，而不是用来随意存放一些
			 int类型的数字
			 
	p=（int *）4；//我明明知道其实就是数字4，但是我强制类型转换成int *类型的4
	           相当于到诉我们编译器，这个4是其实是一个地址（而且是int类型变量的地址）
			   
 }
 int main（void）
 {
    //演示指针的标准使用使用方式  指针是用分3步：定义指针变量、关联指针变量、解引用
    int a=23；    //第一步：定义指针变量
	
	int *p；      //第二步： 绑定指针，其实就是给指针赋值定义指针变量
	p=*a；        //实现指针绑定，让p指向a
	
	*p=555；      //第三步：解引用 把555放入p指向的变量中
 }
 注意：
 (1)当我们 int *p 定义一个指针变量 p 时，因为 p 是局部变量，所以也遵循 C 语言局部变量的
	一般规律（定义局部变量并且未初始化，则值是随机的），所以此时 p 变量中存储的是一个
	随机的数字。
 (2)此时如果我们解引用 p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空
	间到底能不能访问不知道（也许行也许不行），所以如果直接定义指针变量未绑定有效地址
	就去解引用几乎必死无疑。
 (3)定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪随意转了
    几圈然后开了一枪。
 (4)指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方（就好象拿着枪瞄
	准目标的过程一样），指针的解引用是为了间接访问目标变量（就好象开枪是为了打中目标
	一样）
	
4.3.3.3、NULL 到底是什么？
	(1)NULL 在 C/C++中定义为：
			#ifdef _cplusplus // 定义这个符号就表示当前是 C++环境
			#define NULL 0 // 在 C++中 NULL 就是 0
			#else
			#define NULL (void *)0 // 在 C 中 NULL 是强制类型转换为 void *的 0
			#endif
	(2)在 C 语言中，int *p;你可以 p = (int *)0;但是不可以 p = 0;因为类型不相同。
	(3)所以 NULL 的实质其实就是 0，然后我们给指针赋初值为 NULL，其实就是让指针指向 0 地
	址处。为什么指向 0 地址处？2 个原因。第一层原因是 0 地址处作为一个特殊地址（我们认
	为指针指向这里就表示指针没有被初始化，就表示是野指针）；第二层原因是这个地址 0
	地址在一般的操作系统中都是不可被访问的，如果 C 语言程序员不按规矩（不检查是否等于
	NULL 就去解引用）写代码直接去解引用就会触发段错误，这种已经是最好的结果了。
 
4.3.4.const 关键字与指针
	4.3.4.1、const 修饰指针的 4 种形式
		(1)const 关键字，在 C 语言中用来修饰变量，表示这个变量是常量。
		(2)const 修饰指针有 4 种形式，区分清楚这 4 种即可全部理解 const 和指针。
			第一种：const int *p;       //p本身不是const的，而p指向的变量是const的
			第二种：int const *p;       //p本身不是const的，而p指向的变量是const的
			第三种：int * const p;      //p本身是const的，而p指向的变量不是const的
			第四种：const int * const p;//p本身是const的，而p指向的变量不是const的
		(3)关于指针变量的理解，主要涉及到 2 个变量：第一个是指针变量 p 本身，第二个是 p 指
		向的那个变量(*p)。一个 const 关键字只能修饰一个变量，所以弄清楚这 4 个表达式的关键
		就是搞清楚 const 放在某个位置是修饰谁的
 /*
*********************************************************************************************************
*	函 数 名: _GetData
*	功能说明: 被函数GUI_MOVIE_GetInfoEx调用
*	形    参：p             FIL类型数据
*             NumBytesReq   请求读取的字节数
*             ppData        数据指针
*             Off           如果Off = 1，那么将重新从起始位置读取                 
*	返 回 值: 返回读取的字节数
*********************************************************************************************************
*/
int GetData(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off) 
{
	static int Address = 0;
	FILE   *file;
	U32    NumBytesRead;
	U8     * pData;
	pData  = (U8 *)*ppData;
	file = (FILE *)p;
	/*设置读取位置*/
	if(Off == 1) 
	{
		Address = 0;		
	}
	else 
	{
		Address = Off;		
	}
	fseek (file, Address, SEEK_SET);
	/*读取数据到缓存*/
	NumBytesRead = fread (pData, 1, NumBytes, file);
	/*返回读取的字节数*/
	return NumBytesRead;
}

/*
*********************************************************************************************************
*  函 数 名: _ShowJPEG1
*  功能说明: 显示 JPEG 图片
*  形 参:    sFilename 要读取的文件名
*  返 回 值: 无
*********************************************************************************************************
*/
void ShowJPEG(const char *Filename)
{
	    FILE *result;
		/* 打开文件 */ 
		result = fopen ((char *)Filename, "r"); 
		if (result != NULL)
		{
		    return;
		}
		/* 绘制 JPEG 图片 */
		GUI_JPEG_DrawEx(GetData, ffile, 0, 0);
		 /* 关闭文件 */
		 fclose(ffile);
}